# 064 Uplift

## 解法
各クエリである程度広範囲の標高が一度に変わりますが, 愚直にこれを計算していると計算時間が間に合いません. そこで, 「不便さ」が隣り合う区画の差分のみに依存することを利用して, 差分だけを記憶・更新するという方法を考えてみましょう.

数列`D`を, `D[i] = A[i] - A[i+1]` と定めましょう. このとき, `A[l], A[l+1], ..., A[r]`が`v`だけ増加したときに更新するのは`D[l-1]`と`D[r]`だけであり, 1クエリあたりO(1)で計算できるようになります.
不便さを計算する際も, 毎回`D`の総和をO(N)かけて求めるのではなく, 変化する場所だけを見て差分更新すると十分高速に動きます.