# 061 Deck

## 解法
本プログラム中には, 問題で指示された「先頭への要素追加」「末尾への要素追加」「特定indexの要素取得」ができるクラス`Deck`を実装しています. このクラスの実装を見ていきましょう.
`Deck`コンストラクタ内では, 配列`deck`を生成しつつ, 変数`top`と`bot`に120000という値を代入しています. この状態で, `addFirst`を呼ぶと`top`の値が減っていき, `addLast`を呼ぶたびに`bot`の値が増えていきます.
この実装は, 「`deck[top], deck[top+1], ..., deck[bot-1]`のみが有効な(デッキ内部のデータを保持している)部分であり, その左右には余白が広がっている」という状態になっています. 「`k`枚目の取得」は「`deck[top+k]`を返す関数」として実装可能です.

## 参考
Javaの標準ライブラリに, [`java.util.LinkedList`](https://docs.oracle.com/javase/jp/8/docs/api/java/util/LinkedList.html)というものがあります. `addFirst`, `addLast`, `get`が実装されているのでこれがやりたかったことだと思って実装してみた方も少なくないのではと筆者は思っております. ところがこれは罠で, `LinkedList`で実装すると`TLE`になってしまいます. なぜでしょうか.
実は`LinkedList`の`get`関数は計算量が`O(1)`ではなく, 最悪計算量`O(N)`となっています. より正確に言うと, 指定したindexの値に応じて「始端と終端のうち近いほうからそのindexまでの距離」に比例する時間がかかります. よって, 今回の問題で言えば例えば「前半5万クエリで要素追加を行い, 後半5万クエリではデッキの中央の値を問う」というようなケースで`O(N^2)`計算時間がかかってしまいます.
資料としてこの実装を`TimeLimitExceeded.java`にアップロードしてあります. 私が提出した際には6ケースほどTLEが出ました.